% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knn_helpers.R
\name{knn-helpers}
\alias{knn-helpers}
\alias{hnswNN}
\alias{nndescentNN}
\alias{annoyNN}
\title{Wrapper functions for calculating kNN}
\usage{
hnswNN(
  data,
  k,
  query = NULL,
  metric = c("euclidean", "cosine"),
  n.threads = 1,
  seed.use = 42,
  verbose = TRUE,
  by.row = TRUE,
  ef.construction = 200,
  ef = 10
)

nndescentNN(
  data,
  k,
  query = NULL,
  metric = c("euclidean", "cosine", "manhattan", "hamming", "jaccard", "braycurtis",
    "canberra", "chebyshev", "correlation", "dice", "kulsinski", "rogerstanimoto",
    "russellrao", "sqeuclidean", "sokalmichener", "sokalsneath", "yule"),
  n.threads = 1,
  seed.use = 42,
  verbose = TRUE,
  by.row = TRUE,
  eps = 0.1,
  use.alt.metric = FALSE,
  ...
)

annoyNN(
  data,
  k,
  query = NULL,
  metric = c("euclidean", "cosine", "manhattan", "hamming"),
  n.threads = 1,
  seed.use = 42,
  verbose = TRUE,
  by.row = TRUE,
  n.trees = 50,
  search.k = -1,
  ...
)
}
\arguments{
\item{data}{A numeric matrix of observations to build the neighbor indices.}

\item{k}{Number of nearest neighbors to return.}

\item{query}{A numeric matrix of data to search for neighbors. If \code{NULL} as
default, will use \code{data} itself as the query observations.}

\item{metric}{Type of distance calculation to use.}

\item{n.threads}{Number of threads to use.}

\item{seed.use}{Set a random seed. Setting \code{NULL} will not set a seed.}

\item{verbose}{Print progress.}

\item{by.row}{If \code{TRUE} (default), each row of input matrix is treated as an
observation. Otherwise, each observation is stored by column.}

\item{ef.construction}{Size of the dynamic list used during construction.
Pass to \code{\link[RcppHNSW]{hnsw_build}}}

\item{ef}{Size of the dynamic list used during search. Pass to
\code{\link[RcppHNSW]{hnsw_search}}}

\item{eps}{Controls trade-off between accuracy and search cost. Only used in
\code{nndescentNN} when \code{query} is not \code{NULL}. Passed to \code{epsilon} in function
\code{\link[rnndescent]{rnnd_query}}.}

\item{use.alt.metric}{Whether or not to use faster metrics that maintain the
ordering of distances internally. Only used in \code{nndescentNN}. Default is
\code{FALSE} to avoid using squared Euclidean distances when \code{metric} is
"euclidean". Passed to \code{use_alt_metric} in \code{\link[rnndescent]{nnd_knn}}.}

\item{...}{Arguments passed to other metheds.
\itemize{
\item \code{nndescentNN}: Passed to either \code{\link[rnndescent]{nnd_knn}} when
\code{query = NULL}, or \code{\link[rnndescent]{rnnd_build}}
\item \code{annoyNN}: Passed to \code{\link{annoy_search}}
}}

\item{n.trees}{Passed to \code{\link{annoy_build}}.}

\item{search.k}{Passed to \code{\link{annoy_search}}.}
}
\value{
A list containing \code{idx} matrix and \code{dist} matrix. Each row represents an
observation in NN results.
}
\description{
Wrapper functions for calculating kNN with different methods. The parameters
of each method have been unified.
}
\examples{
nn1 <- hnswNN(pca, k = 8)

nn2 <- nndescentNN(pca, k = 8)

nn3 <- annoyNN(pca, k = 8)

}
\seealso{
\itemize{
\item \code{\link[RcppHNSW]{hnsw_build}} and \code{\link[RcppHNSW]{hnsw_search}} from
\pkg{RcppHNSW}
}

#' \itemize{
\item \code{\link[rnndescent]{nnd_knn}} from \pkg{rnndescent}
}
}
